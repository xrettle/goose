name: Daily Test Coverage Finder

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (no PR creation)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

jobs:
  find-untested-code:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/block/goose:latest
      options: --user root
      env:
        GOOSE_PROVIDER: ${{ vars.GOOSE_PROVIDER || 'openai' }}
        GOOSE_MODEL: ${{ vars.GOOSE_MODEL || 'gpt-5' }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        HOME: /tmp/goose-home

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # pin@v4
        with:
          fetch-depth: 0

      - name: Install build and analysis tools
        run: |
          apt-get update
          apt-get install -y jq ripgrep build-essential

      - name: Find untested code and create working test
        id: find_untested
        run: |
          # Ensure the HOME directory structure exists
          mkdir -p $HOME/.local/share/goose/sessions
          mkdir -p $HOME/.config/goose

          # Create analysis and test creation script
          cat << 'EOF' > /tmp/create_working_test.txt
          Your task is to find ONE untested function in the Rust codebase and create a working test for it.

          Requirements:
          1. The function MUST be in the crates/ directory
          2. It MUST have actual logic (not just a simple getter/setter)
          3. It MUST not already have a test
          4. Prefer functions with complexity but that are still testable in isolation
          5. Focus on the goose crate first, then goose-cli, then others

          Process:
          1. Find a suitable untested function (use your `analyze` tool and ripgrep)
          2. Write a comprehensive unit test for it
          3. Apply your changes to the codebase
          4. Run the test with: cargo test --test <test_name>
          5. If the test fails:
             - Read and understand the error message
             - Fix the test code
             - Apply the fix and run the test again
             - Repeat up to 3 times until the test passes
          6. Once the test passes (or after 3 attempts), save the final changes as a git diff to /tmp/test_addition.patch
          7. Report the outcome:
             - If successful: write "SUCCESS" to /tmp/test_result.txt
             - If no suitable function found: write "NO_FUNCTION_FOUND" to /tmp/test_result.txt
             - If test couldn't be fixed: write "TEST_FAILED" to /tmp/test_result.txt

          Important:
          - Only add ONE test for ONE function
          - The test MUST compile and pass before creating the patch
          - Keep changes minimal and focused
          - Include a descriptive test name that explains what is being tested
          EOF

          goose run -i /tmp/create_working_test.txt --with-builtin developer

          # Check the result
          if [ -f /tmp/test_result.txt ]; then
            RESULT=$(cat /tmp/test_result.txt)
            echo "Test creation result: $RESULT"

            if [ "$RESULT" = "SUCCESS" ] && [ -f /tmp/test_addition.patch ]; then
              echo "patch_created=true" >> $GITHUB_OUTPUT
              # Extract function name from patch for PR title
              FUNC_NAME=$(grep -E "fn test_|#\[test\]" /tmp/test_addition.patch | head -1 | sed 's/.*test_//' | sed 's/(.*//' || echo "function")
              echo "function_name=${FUNC_NAME}" >> $GITHUB_OUTPUT
            else
              echo "patch_created=false" >> $GITHUB_OUTPUT
              echo "Reason: $RESULT"
            fi
          else
            echo "patch_created=false" >> $GITHUB_OUTPUT
            echo "No result file created"
          fi

      - name: Extract token metrics
        id: metrics
        run: |
          # Find the most recently created session file in the goose sessions directory
          SESSION_DIR="$HOME/.local/share/goose/sessions"
          if [ -d "$SESSION_DIR" ]; then
            SESSION_FILE=$(ls -t "$SESSION_DIR"/*.jsonl 2>/dev/null | head -1)
            if [ -f "$SESSION_FILE" ]; then
              echo "Found session file: $SESSION_FILE"
              # Current context size metrics
              TOKENS=$(head -1 "$SESSION_FILE" | jq -r '.total_tokens // 0')
              INPUT_TOKENS=$(head -1 "$SESSION_FILE" | jq -r '.input_tokens // 0')
              OUTPUT_TOKENS=$(head -1 "$SESSION_FILE" | jq -r '.output_tokens // 0')
              echo "total_tokens=${TOKENS}" >> $GITHUB_OUTPUT
              echo "input_tokens=${INPUT_TOKENS}" >> $GITHUB_OUTPUT
              echo "output_tokens=${OUTPUT_TOKENS}" >> $GITHUB_OUTPUT
              # Accumulated API usage metrics
              ACC_TOKENS=$(head -1 "$SESSION_FILE" | jq -r '.accumulated_total_tokens // 0')
              ACC_INPUT_TOKENS=$(head -1 "$SESSION_FILE" | jq -r '.accumulated_input_tokens // 0')
              ACC_OUTPUT_TOKENS=$(head -1 "$SESSION_FILE" | jq -r '.accumulated_output_tokens // 0')
              echo "accumulated_total_tokens=${ACC_TOKENS}" >> $GITHUB_OUTPUT
              echo "accumulated_input_tokens=${ACC_INPUT_TOKENS}" >> $GITHUB_OUTPUT
              echo "accumulated_output_tokens=${ACC_OUTPUT_TOKENS}" >> $GITHUB_OUTPUT
              echo "Token usage - Total: ${TOKENS}, Input: ${INPUT_TOKENS}, Output: ${OUTPUT_TOKENS}"
              echo "Accumulated usage - Total: ${ACC_TOKENS}, Input: ${ACC_INPUT_TOKENS}, Output: ${ACC_OUTPUT_TOKENS}"
            fi
          fi

      - name: Create Pull Request
        if: steps.find_untested.outputs.patch_created == 'true' && github.event.inputs.dry_run != 'true'
        uses: peter-evans/create-pull-request@271a8d0340265f705b14b6d32b9829c1cb33d45e # pin@v7.0.8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "test: add test for ${{ steps.find_untested.outputs.function_name }}"
          title: "test: add test coverage for ${{ steps.find_untested.outputs.function_name }}"
          body: |
            ## ü§ñ Automated Test Addition

            This PR was automatically generated by Goose to improve test coverage.

            ### What changed?
            Added a unit test for a previously untested function.

            ### Why?
            Part of our daily automated test coverage improvement initiative. Goose analyzes the codebase to find untested but important functions and creates focused unit tests for them.

            ### Review checklist
            - [ ] Test is meaningful and actually tests the function
            - [ ] Test name is descriptive
            - [ ] Test passes locally
            - [ ] No unnecessary changes included

            ### Metrics
            #### Current Context Size
            - **Total**: ${{ steps.metrics.outputs.total_tokens }} tokens
            - **Input**: ${{ steps.metrics.outputs.input_tokens }} tokens
            - **Output**: ${{ steps.metrics.outputs.output_tokens }} tokens
            #### API Usage (Billable)
            - **Total**: ${{ steps.metrics.outputs.accumulated_total_tokens }} tokens
            - **Input**: ${{ steps.metrics.outputs.accumulated_input_tokens }} tokens
            - **Output**: ${{ steps.metrics.outputs.accumulated_output_tokens }} tokens

            ---
            *Generated by the Daily Test Coverage Finder workflow*
          branch: goose/test-coverage-${{ github.run_number }}
          delete-branch: true
          labels: |
            goose-generated
            test
            automated

      - name: Summary
        if: always()
        env:
          PATCH_CREATED: ${{ steps.find_untested.outputs.patch_created }}
          FUNCTION_NAME: ${{ steps.find_untested.outputs.function_name }}
        run: |
          if [ "$PATCH_CREATED" = "true" ]; then
            echo "‚úÖ Successfully found untested code and created a test"
            echo "üìù Function tested: $FUNCTION_NAME"
          else
            echo "‚ÑπÔ∏è No suitable untested code found today"
          fi
