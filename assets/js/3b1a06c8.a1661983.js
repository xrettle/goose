"use strict";(self.webpackChunkgoose=self.webpackChunkgoose||[]).push([[9213],{81507:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>n,toc:()=>l});var n=t(7686),s=t(74848),i=t(28453);const r={title:"What's in my .goosehints file (and why it probably shouldn't be)",description:"A deep dive into .goosehints vs Memory Extension, and how to optimize your Goose configuration for better performance",authors:["ian"]},a="What's in my .goosehints file (and why it probably shouldn't be)",h={authorsImageUrls:[void 0]},l=[{value:"AI Agents and Memory",id:"ai-agents-and-memory",level:2},{value:"What is .goosehints?",id:"what-is-goosehints",level:3},{value:"What is the Memory Extension?",id:"what-is-the-memory-extension",level:3},{value:"How are .goosehints and Memory Extension used in Goose?",id:"how-are-goosehints-and-memory-extension-used-in-goose",level:2},{value:"The Implications of .goosehints vs Memory Extension",id:"the-implications-of-goosehints-vs-memory-extension",level:2},{value:"Where I went wrong with my .goosehints",id:"where-i-went-wrong-with-my-goosehints",level:2},{value:"So what &quot;belongs&quot; in .goosehints?",id:"so-what-belongs-in-goosehints",level:3},{value:"Everything else got moved into the Memory Extension",id:"everything-else-got-moved-into-the-memory-extension",level:2},{value:"To hint, or not to hint?",id:"to-hint-or-not-to-hint",level:2}];function d(e){const o={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Head:n}=o;return n||function(e,o){throw new Error("Expected "+(o?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.p,{children:(0,s.jsx)(o.img,{alt:"blog cover",src:t(66786).A+"",width:"1809",height:"950"})}),"\n",(0,s.jsxs)(o.p,{children:["As Goose users, we have two main ways to provide persistent context to our AI assistant: the ",(0,s.jsx)(o.code,{children:".goosehints"})," file and the ",(0,s.jsx)(o.a,{href:"/docs/mcp/memory-mcp",children:"Memory Extension"})," MCP server. Today, I'll share what's in my ",(0,s.jsx)(o.code,{children:".goosehints"})," file, why some of it should probably move to the Memory Extension, and how you can make that choice."]}),"\n",(0,s.jsx)(o.h2,{id:"ai-agents-and-memory",children:"AI Agents and Memory"}),"\n",(0,s.jsx)(o.p,{children:'Imagine ordering coffee at two different cafes. At the first cafe, you\'re a first-time customer, carefully explaining "medium mocha latte, fat-free milk, extra hot, no foam, with one pump of vanilla." At your regular coffee spot, though, the barista sees you coming and just says "the usual?"'}),"\n",(0,s.jsx)(o.p,{children:"That stored knowledge \u2013 your preferences, quirks, and routine \u2013 makes the whole interaction faster and more pleasant for everyone."}),"\n",(0,s.jsx)(o.p,{children:"This is exactly the challenge we face with AI assistants. By default, they start each conversation (aka, \"context window\") fresh \u2013 no memory of your coding standards, documentation preferences, or how you like your pull requests structured. The same way you'd get tired of reciting your detailed coffee order every morning, it's inefficient to repeatedly explain to your AI assistant that you prefer Python's Black formatter, want detailed commit messages, and or how you want to construct a briefing going to everyone in the company."}),"\n",(0,s.jsxs)(o.p,{children:["This is where persistent context comes in. Through tools like ",(0,s.jsx)(o.code,{children:".goosehints"})," and the ",(0,s.jsx)(o.a,{href:"/docs/mcp/memory-mcp",children:"Memory Extension"})," MCP server, we can give our AI assistants the equivalent of a barista's \"regular customer\" knowledge. But just as you wouldn't want your barista memorizing your entire life story just to make your coffee, we need to be thoughtful about what context we make persistent. The key is finding the right balance between having enough context to work efficiently and not overwhelming our systems with unnecessary information."]}),"\n",(0,s.jsx)(o.p,{children:"Let's explore how to strike that balance."}),"\n",(0,s.jsx)(o.h3,{id:"what-is-goosehints",children:"What is .goosehints?"}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:".goosehints"})," is a configuration file that lives in your Goose directory (usually ",(0,s.jsx)(o.code,{children:"~/.config/goose/"}),"). It can contain any information that you want Goose to process every time you interact with Goose, providing a foundation for how it interacts with you."]}),"\n",(0,s.jsxs)(o.p,{children:["You can read more about ",(0,s.jsx)(o.code,{children:".goosehints"})," in the ",(0,s.jsx)(o.a,{href:"/docs/guides/using-goosehints",children:"Goose documentation"}),"."]}),"\n",(0,s.jsx)(o.h3,{id:"what-is-the-memory-extension",children:"What is the Memory Extension?"}),"\n",(0,s.jsxs)(o.p,{children:["The ",(0,s.jsx)(o.a,{href:"/docs/mcp/memory-mcp",children:"Memory Extension"})," is a dynamic storage system using the Model Context Protocol that allows you to store and retrieve context on-demand using tags or keywords. It lives in your ",(0,s.jsx)(o.code,{children:"~/.goose/memory"})," directory (local) or ",(0,s.jsx)(o.code,{children:"~/.config/goose/memory"})," (global)."]}),"\n",(0,s.jsxs)(o.p,{children:["Unlike ",(0,s.jsx)(o.code,{children:".goosehints"}),", which is static and loaded entirely with every request, Memory Extension can be updated and accessed as needed, allowing for more flexible and user-specific configurations."]}),"\n",(0,s.jsx)(o.h2,{id:"how-are-goosehints-and-memory-extension-used-in-goose",children:"How are .goosehints and Memory Extension used in Goose?"}),"\n",(0,s.jsx)(o.p,{children:"At a very high level, when you have a conversation with Goose, it processes your request in two main steps:"}),"\n",(0,s.jsxs)(o.p,{children:["Goose interprets your request to detect tags or keywords needed for possible Memory Extension lookups. Then it loads your entire ",(0,s.jsx)(o.code,{children:".goosehints"})," file, and sends that, along with all Memory Extension entries to the LLM to generate a response."]}),"\n",(0,s.jsxs)(o.p,{children:["Why send both? Because the LLM interaction is stateless, and needs the full context of both the goosehints and Memory Extension to generate an appropriate response. The ",(0,s.jsx)(o.code,{children:".goosehints"})," file provides static, project-wide context, while the Memory Extension provides dynamic, user-specific context."]}),"\n",(0,s.jsx)(o.h2,{id:"the-implications-of-goosehints-vs-memory-extension",children:"The Implications of .goosehints vs Memory Extension"}),"\n",(0,s.jsxs)(o.p,{children:["Since the entire ",(0,s.jsx)(o.code,{children:".goosehints"})," file and all of the memories get sent with every request, why have two different ways to provide rules and context?"]}),"\n",(0,s.jsxs)(o.p,{children:["The key difference lies in ",(0,s.jsx)(o.strong,{children:"scope"})," and ",(0,s.jsx)(o.strong,{children:"flexibility"}),":"]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.strong,{children:".goosehints"}),": This file is your project's static context. It's great for defining overarching rules, standards, and documentation that apply to all interactions with Goose. However, because it's static, any changes require editing the file and reloading it. You CAN create a global ",(0,s.jsx)(o.code,{children:".goosehints"})," file that applies to all projects, but you can also create a project-specific ",(0,s.jsx)(o.code,{children:".goosehints"})," file that only applies to a specific project. This is useful for defining project-wide coding standards, documentation preferences, or other static rules that you want to apply consistently across all interactions."]}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.strong,{children:"Memory Extension"}),": This is your dynamic context. It allows you to store and retrieve information on-the-fly, making it perfect for user-specific preferences, temporary context, or information that changes frequently. You can update memories without modifying the ",(0,s.jsx)(o.code,{children:".goosehints"})," file, providing greater flexibility. The memories are generally tied to the specific user, though they could be shared if your team chooses to do so (but this isn't the norm)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(o.h2,{id:"where-i-went-wrong-with-my-goosehints",children:"Where I went wrong with my .goosehints"}),"\n",(0,s.jsxs)(o.p,{children:["When I first started using Goose, I treated ",(0,s.jsx)(o.code,{children:".goosehints"})," like a catch-all for everything I wanted Goose to remember, because I didn't know about the Memory Extension. My ",(0,s.jsx)(o.code,{children:".goosehints"})," file included:"]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:"rules on writing outlines for blog posts"}),"\n",(0,s.jsx)(o.li,{children:"how I like Python code written and formatted"}),"\n",(0,s.jsx)(o.li,{children:"notes about frontend development"}),"\n",(0,s.jsx)(o.li,{children:"etc"}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"The file was enormous and hard to update."}),"\n",(0,s.jsx)(o.h3,{id:"so-what-belongs-in-goosehints",children:'So what "belongs" in .goosehints?'}),"\n",(0,s.jsx)(o.p,{children:"Here's something I end nearly every AI prompt with:"}),"\n",(0,s.jsxs)(o.blockquote,{children:["\n",(0,s.jsxs)(o.p,{children:["If you're not 95% sure how to complete these instructions, or that you'll be at least 95% factually accurate, ",(0,s.jsx)(o.strong,{children:"do not guess or make things up"}),". Stop and ask me for more information or direction. If you're finding resources online, give me 1 or 2 URLs that informed your response."]}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"I also like to end many of my prompts asking if Goose has any clarifying questions before doing the work I'm attempting:"}),"\n",(0,s.jsxs)(o.blockquote,{children:["\n",(0,s.jsxs)(o.p,{children:["Based on the information I've provided, ask me any clarifying questions ",(0,s.jsx)(o.strong,{children:"before"})," doing any work, or tell me that you're ready to proceed."]}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"Since these are things that I definitely want to add to every request I make to Goose, I've simplified my .goosehints file to include only these types of rules and standards."}),"\n",(0,s.jsx)(o.h2,{id:"everything-else-got-moved-into-the-memory-extension",children:"Everything else got moved into the Memory Extension"}),"\n",(0,s.jsx)(o.p,{children:'The Memory Extension uses a tagging system to remember context based on keywords. You can give Goose a command to "remember" something, and Goose will write a Memory entry with appropriate tags. The next time you ask Goose to do something with Python, it will parse your request, look for relevant tags, and use appropriate Memory entries to send as part of the context for just that request.'}),"\n",(0,s.jsx)(o.p,{children:"So all of my Python rules can be written as a command to Goose like this:"}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-text",children:"Remember that when I ask about Python, I want to conform to the following standards and guidelines:\n- use Python 3.12+ syntax\n- use type hints for all function signatures\n- use f-strings for string formatting\n- use the latest Python features and libraries\n- use Flake8 for linting\n- use black for formatting\n- if I ask to build a CLI based tool, expect to take command line arguments and make a colorful interface using ANSI colors and the rich library\n- if I ask to build an API, expect to build a RESTful API use FastAPI and to send back data in JSON format\n"})}),"\n",(0,s.jsx)(o.p,{children:"Now, Goose will only send these Python-related rules when I ask it to do something with Python. This is far more efficient."}),"\n",(0,s.jsx)(o.p,{children:"Here's the resulting Memory file that Goose made:"}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-text",children:"# python standards development formatting linting api cli\nPython Development Standards:\n- Python version: 3.12+\n- Mandatory type hints for all function signatures\n- Use f-strings for string formatting\n- Use latest Python features and libraries\n- Code formatting: black\n- Linting: Flake8\n- CLI tools: Use command line arguments and rich library for colorful interface\n- APIs: Use FastAPI for RESTful APIs with JSON responses\n"})}),"\n",(0,s.jsxs)(o.p,{children:["The first line starts with a hash ",(0,s.jsx)(o.code,{children:"#"})," and a space-separated list of keywords and tags that it will use to discern when or whether to retrieve this content to send with a request to my LLM."]}),"\n",(0,s.jsx)(o.h2,{id:"to-hint-or-not-to-hint",children:"To hint, or not to hint?"}),"\n",(0,s.jsxs)(o.p,{children:["Since both the ",(0,s.jsx)(o.code,{children:".goosehints"})," file and the Memory Extension files are sent with every request, whether to use one or the other really comes down to how you want to manage your context. Since you can create a project-specific ",(0,s.jsx)(o.code,{children:".goosehints"})," file, you can use it to define project-wide rules and standards that you want to apply consistently across all interactions with Goose. This is useful for defining project-wide coding standards, documentation preferences, or other static rules that you want to apply consistently across all interactions. Meanwhile you can maintain a personal set of standards for writing and coding in your Memory Extension that you can update and change as needed without affecting the project-wide rules."]}),"\n",(0,s.jsxs)(o.p,{children:["Share your own ",(0,s.jsx)(o.code,{children:".goosehints"})," optimization stories in the ",(0,s.jsx)(o.a,{href:"http://discord.gg/block-opensource",children:"Goose community on Discord"}),"!"]}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsx)("meta",{property:"og:title",content:"What's in my .goosehints file (and why it probably shouldn't be)"}),(0,s.jsx)("meta",{property:"og:type",content:"article"}),(0,s.jsx)("meta",{property:"og:url",content:"https://block.github.io/goose/blog/2025/06/05/whats-in-my-goosehints-file"}),(0,s.jsx)("meta",{property:"og:description",content:"Learn how to optimize your Goose configuration by understanding when to use .goosehints vs Memory Extension for better performance and maintainability."}),(0,s.jsx)("meta",{property:"og:image",content:"https://block.github.io/goose/assets/images/blog-banner-7f0e5ed1cf875e64e3ebb3250932baaf.png"}),(0,s.jsx)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,s.jsx)("meta",{property:"twitter:domain",content:"block.github.io/goose"}),(0,s.jsx)("meta",{name:"twitter:title",content:"What's in my .goosehints file (and why it probably shouldn't be)"}),(0,s.jsx)("meta",{name:"twitter:description",content:"Learn how to optimize your Goose configuration by understanding when to use .goosehints vs Memory Extension for better performance and maintainability."}),(0,s.jsx)("meta",{name:"twitter:image",content:"https://block.github.io/goose/assets/images/blog-banner-7f0e5ed1cf875e64e3ebb3250932baaf.png"}),(0,s.jsx)("meta",{name:"keywords",content:"Goose; .goosehints; Memory Extension MCP; AI configuration; performance optimization; developer productivity; context management; AI assistant; token costs; LLM efficiency"})]})]})}function c(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},66786:(e,o,t)=>{t.d(o,{A:()=>n});const n=t.p+"assets/images/blog-banner-7f0e5ed1cf875e64e3ebb3250932baaf.png"},28453:(e,o,t)=>{t.d(o,{R:()=>r,x:()=>a});var n=t(96540);const s={},i=n.createContext(s);function r(e){const o=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(i.Provider,{value:o},e.children)}},7686:e=>{e.exports=JSON.parse('{"permalink":"/goose/blog/2025/06/05/whats-in-my-goosehints-file","source":"@site/blog/2025-06-05-whats-in-my-goosehints-file/index.md","title":"What\'s in my .goosehints file (and why it probably shouldn\'t be)","description":"A deep dive into .goosehints vs Memory Extension, and how to optimize your Goose configuration for better performance","date":"2025-06-05T00:00:00.000Z","tags":[],"readingTime":7.755,"hasTruncateMarker":true,"authors":[{"name":"W Ian Douglas","title":"Staff Developer Advocate","page":{"permalink":"/goose/blog/authors/ian"},"socials":{"linkedin":"https://www.linkedin.com/in/iandouglas736/","github":"https://github.com/iandouglas","bluesky":"https://bsky.app/profile/iandouglas736.com","x":"https://x.com/iandouglas736"},"imageURL":"https://avatars.githubusercontent.com/u/168030?v=4","key":"ian"}],"frontMatter":{"title":"What\'s in my .goosehints file (and why it probably shouldn\'t be)","description":"A deep dive into .goosehints vs Memory Extension, and how to optimize your Goose configuration for better performance","authors":["ian"]},"unlisted":false,"prevItem":{"title":"Treating LLMs Like Tools in a Toolbox: A Multi-Model Approach to Smarter AI Agents","permalink":"/goose/blog/2025/06/16/multi-model-in-goose"},"nextItem":{"title":"Democratizing Detection Engineering at Block: Taking Flight with Goose and Panther MCP","permalink":"/goose/blog/2025/06/02/goose-panther-mcp"}}')}}]);